<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Ajouter une fonction dans votre package</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ma√´l THEULIERE - Juliette ENGELAERE-LEFEBVRE" />
    <meta name="date" content="2021-05-02" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/shareon/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain/shareagain.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <meta name="description" content="Aprendre comment int√©grer une fonction dans votre package."/>
    <meta name="generator" content="xaringan et remark.js"/>
    <meta name="github-repo" content="maeltheuliere/ateliers_rpackage"/>
    <meta name="twitter:title" content="Cr√©er son premier package R - Ajouter une fonction dans votre package"/>
    <meta name="twitter:description" content="Aprendre comment int√©grer une fonction dans votre package."/>
    <meta name="twitter:url" content="https://maeltheuliere.github.io/ateliers_rpackage/atelier3.html"/>
    <meta name="twitter:image:src" content="https://maeltheuliere.github.io/ateliers_rpackage/slides/www/slide2.png"/>
    <meta name="twitter:image:alt" content="Diapo titre du diaporama ajouter une fonction dans votre package"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta property="og:title" content="Cr√©er son premier package R - Ajouter une fonction dans votre package"/>
    <meta property="og:description" content="Aprendre comment int√©grer une fonction dans votre package."/>
    <meta property="og:url" content="https://maeltheuliere.github.io/ateliers_rpackage/atelier3.html"/>
    <meta property="og:image" content="https://maeltheuliere.github.io/ateliers_rpackage/slides/www/slide2.png"/>
    <meta property="og:image:alt" content="Diapo titre du diaporama ajouter une fonction dans votre package"/>
    <meta property="og:type" content="website"/>
    <meta property="og:locale" content="en_US"/>
    <meta property="article:author" content="Juliette ENGELAERE-LEFEBVRE - Ma√´l THEULIERE"/>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="libs/font-awesome/css/all.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="progress-bar.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


















class: center, middle

.fl.w-40.pa2[
![](https://raw.githubusercontent.com/MaelTheuliere/ateliers_rpackage/main/slides/www/packagescompagnons.png)&lt;!-- --&gt;
]

.fl.w-60.pa2[

.f3[Cr√©er son premier] .yellow.f3[package R]

.f1[Ajouter] .yellow.f1[une fonction] .f1[dans votre package]
]

.tr[
.f4[Juliette ENGELAERE-LEFEBVRE - Ma√´l THEULIERE]
]
---
# Objectif de cet atelier

Apr√®s cet atelier vous saurez ajouter une fonction dans un package. C‚Äôest √† dire que vous aurez compris :  

- ce qu‚Äôest une fonction ;  
- comment ajouter une fonction dans un package ;  
- comment documenter une fonction ;
- comment tester une fonction.  

---
class: inverse, center, middle

# Qu'est ce qu'une fonction ?
---

# Qu'est ce qu'une fonction ?

Une fonction est un objet de R. C'est une op√©ration qui prend en entr√©e des arguments pour produire un r√©sultat.

Par exemple : 

- `abs()` prend comme argument un vecteur de nombre et produit un vecteur de nombre contenant la valeur absolue des nombres en argument.

- `select()` de `{dplyr}` prend comme argument un dataframe et une liste de colonnes et produit en sortie un dataframe restreint √† ces colonnes.

- `write.csv()` prend en argument un dataframe, un lien vers un fichier, et produit en sortie un fichier csv contenant le dataframe, √† l'endroit sp√©cifi√© par le lien.
---
# D√©finir une fonction

Une fonction classique dans R se d√©finie de la sorte : 


```r
ma_fonction &lt;- function(a = 2, b = 1){
  resultat &lt;- a + 2*b
  return(resultat)
}
```

L'instruction `function()` cr√©er une fonction ici appel√©e `ma_fonction()`. 

Elle prend en arguments les param√®tres de notre fonction, ici `a` et `b` auxquels ont peut assigner des valeurs par d√©faut, ici `2` et `1`. 

L'int√©rieur de nos accolades `{}` va d√©finir le r√©sultat produit par notre fonction. Ce r√©sultat doit √™tre retourn√© par l'instruction `return()`.

Voil√† comment se d√©finit une fonction type qui produit en retour un objet R. Certaines fonctions ne produisent pas des objets R mais des instructions, comme par exemple `write.csv()` vu pr√©c√©demment.


---

# Les bonnes pratiques

Pour cr√©er une bonne fonction, il faut bien penser sa coh√©rence dans le workflow dans lequelle elle va s'inscrire : 

- Pour faire telle op√©ration, dois je cr√©er une fonction ou deux car un r√©sultat interm√©diaire pourrait m'int√©resser ailleurs ? 

- Quels param√®tres ? 

- Quelle compl√©mentarit√© avec les fonctions existantes ?

- Quelle convention de nommage ?

Ensuite cette fonction devra √™tre correctement document√©e et test√©e. On verra dans la suite ce qu'est un test.

---
class: inverse, center, middle
# Ajouter une fonction dans votre package

---
#### Ajouter une fonction dans votre package

# cr√©er le fichier .R

.pull-left[
Pour rappel, le code d'une fonction doit √™tre rajout√© dans un script R du sous r√©pertoire `R/`.

Pour rajouter une fonction dans votre package, `{usethis}` vous facilite le travail :  `usethis::use_r("ma_fonction")` va cr√©er un fichier `ma_fonction.R` dans votre r√©pertoire `R/`.
]

.pull-right[
![](www/ma_fonction.png)
]
---
#### Ajouter une fonction dans votre package

# Ajouter votre fonction dans le fichier

.pull-left[
Ici on cr√©e la fonction `ma_fonction` qui prend en param√®tres : 

- un dataframe `data`,
- deux nombres `n_head` et `n_tail`,

et produit en sortie un dataframe contenant le d√©but et la fin du dataframe `data`, en gardant `n_head` lignes du d√©but et `n_tail` lignes de la fin.

‚ö†Ô∏è Dans une fonction, il est commun d'utiliser des fonctions d'autres packages. Dans ce cas, appelez-les en utilisant la convention `packages::fonction()`.
]

.pull-right[

```r
ma_fonction &lt;- function(data = NULL,
                        n_head = 3,
                        n_tail = 3){
  res &lt;- rbind(dplyr::slice_head(data,
                                 n = n_head),
               dplyr::slice_tail(data,
                                 n = n_tail)
  )
  return(res)
}
```

]

---

#### Ajouter une fonction dans votre package

# Utiliser votre fonction

`devtools::load_all()` vous permet de charger le contenu du package sur lequel vous travaillez, comme si vous l'aviez install√©. Dans votre workflow habituel, vous allez utiliser souvent cette fonction pour tester les fonctions que vous ajoutez.


```r
devtools::load_all()
```

Vous pouvez ensuite constater que votre fonction marche correctement üéâ


```r
ma_fonction(iris, 2, 3)
```

```
##   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
## 1          5.1         3.5          1.4         0.2    setosa
## 2          4.9         3.0          1.4         0.2    setosa
## 3          6.5         3.0          5.2         2.0 virginica
## 4          6.2         3.4          5.4         2.3 virginica
## 5          5.9         3.0          5.1         1.8 virginica
```

---
class: inverse, center, middle
# Documenter votre fonction
---
#### Documenter votre fonction
# {roxygen2}

Le package `{roxygen2}` va vous permettre de documenter votre fonction afin qu'une aide soit accessible pour celle-ci.  

---
#### Documenter votre fonction

# {roxygen2} : cr√©er un canevas

.pull-left[
Pour ajouter une documentation, mettez le pointeur sur la fonction dans son script et utiliser le raccourci clavier `Ctrl + Alt + Shift + R` ou utiliser l'interface de Rstudio en cliquant sur `Code Tools`.
]

.pull-right[
![](www/ma_fonction_roxygen2.png)
]

---
#### Documenter votre fonction

# {roxygen2} : cr√©er un canevas

.pull-left[
Pour ajouter une documentation, mettez le pointeur sur la fonction dans son script et utiliser le raccourci clavier `Ctrl + Alt + Shift + R` ou utilisez l'interface de Rstudio en cliquant sur `Code Tools`.

Une fois activ√©, roxygen2 vous rajoute un canevas de documentation.
]

.pull-right[
![](www/ma_fonction_roxygen2_caneva.png)
]
---
#### Documenter votre fonction

# {roxygen2} : compl√©ter votre documentation

.pull-left[
Vous n'avez plus qu'√† compl√©ter üéâ! 
]
.pull-right[

```r
#' Garder les lignes de d√©but et de fin d'un dataframe
#'
#' @param data un dataframe
#' @param n_head le nombre de lignes √† garder du d√©but du fichier
#' @param n_tail le nombre de lignes √† garder de la fin du fichier
#'
#' @return un dataframe
#' @export
#'
#' @examples
#' ma_fonction(mpg,3,3)
ma_fonction &lt;- function(data = NULL,
                        n_head = 3,
                        n_tail = 3){
  res &lt;- rbind(dplyr::slice_head(data, n = n_head),
               dplyr::slice_tail(data, n = n_tail)
  )
  return(res)
}
```

]
---
#### Documenter votre fonction

# {roxygen2} : gestion des d√©pendances

.pull-left[
`{roxygen2}` permet non seulement de g√©rer la documentation mais aussi les d√©pendances et les exports de notre package. Cela se traduit par l'alimentation du fichier `NAMESPACE`.

La balise `@importFrom` permet de pr√©ciser les fonctions qu'on utilise dans le package. Cet ajout permettra de compl√©ter le fichier `NAMESPACE` avec les d√©pendances de notre package.

On ajoute une balise `@importFrom` pour chaque package utilis√©.

]
.pull-right[

```r
#' Garder les lignes de d√©but et de fin d'un dataframe
#'
#' @param data un dataframe
#' @param n_head le nombre de lignes √† garder du d√©but du fichier
#' @param n_tail le nombre de lignes √† garder de la fin du fichier
#'
#' @return un dataframe
#' @importFrom dplyr slice_head slice_tail
#' @export
#'
#' @examples
#' ma_fonction(mpg,3,3)
ma_fonction &lt;- function(data = NULL,
                        n_head = 3,
                        n_tail = 3){
  res &lt;- rbind(dplyr::slice_head(data, n = n_head),
               dplyr::slice_tail(data, n = n_tail)
  )
  return(res)
}
```

]
---
#### Documenter votre fonction

# {roxygen2} : gestion des exports

.pull-left[
La balise `@export` permet aussi de compl√©ter le fichier `NAMESPACE` en lui pr√©cisant cette fois ci que `ma_fonction()` est une fonction *export√©e* de `{monpackage}`. 

Si cette balise n'est pas ajout√©e, dans ce cas, la fonction restera purement interne au package. Cela est une convention utile pour d√©finir des fonctions n√©cessaires √† d'autres fonctions du package mais pas directement utiles pour les utilisateurs.

]
.pull-right[

```r
#' Garder les lignes de d√©but et de fin d'un dataframe
#'
#' @param data un dataframe
#' @param n_head le nombre de lignes √† garder du d√©but du fichier
#' @param n_tail le nombre de lignes √† garder de la fin du fichier
#'
#' @return un dataframe
#' @importFrom dplyr slice_head slice_tail
#' @export
#'
#' @examples
#' ma_fonction(mpg,3,3)
ma_fonction &lt;- function(data = NULL,
                        n_head = 3,
                        n_tail = 3){
  res &lt;- rbind(dplyr::slice_head(data, n = n_head),
               dplyr::slice_tail(data, n = n_tail)
  )
  return(res)
}
```

]
---
#### Documenter votre fonction  
# Des actuces avec `{prefixer}`  ![](www/addin_prefixer_logo.png)     
.pull-left[

Le package `{prefixer}` permet de finaliser votre fonction et produire la documentation plus facilement.  

Il s'installe via :   

```r
remotes::install_github("dreamRs/prefixer")
```
Il s'agit d'un package qui installe un addin, c'est √† dire qui ajoute des fonctionnalit√©s √† RStudio.  

L'objectif des addins est g√©n√©ralement d'acc√©l√©rer la r√©alisation de t√¢ches r√©p√©titives ou fastidieuses.
]
.pull-right[   
On acc√®de aux fonctionnalit√©s nouvelles via le menu addins :    

![](www/addin_prefixer.png)  
  
On peut ajouter des raccourcis clavier pour acc√©l√©rer encore l'utilisation des fonctions des addins.
]
---
#### Documenter votre fonction - Astuces `{prefixer}`  
# Commande addin `Prefixer::`   

La commande `Prefixer::` ouvre une boite de dialogue qui vous propose d'ajouter, pour chaque fonction utilis√©e dans notre script de d√©finition de fonction, le pr√©fixe ad√©quat.     

‚ö†Ô∏è Seuls les packages actuellement actifs (appel√©s via `library`) seront propos√©s.  

![](www/addin_prefixer_fonct.png)

La commande `Unprefix` supprime tous les pr√©fixes de notre script actif.

---
#### Documenter votre fonction - Astuces `{prefixer}`     
# Commande addin `@importFrom`  

.pull-left[
La commande `@importFrom` :  

- parcourt votre script de d√©finition de fonction, 
- y d√©tecte toutes les pr√©fixes utilis√©s et
- ajoute au dessus de la fonction, la ou les balises `@importFrom package1 fonctions1`
]

.pull-right[
![](www/addin_prefixer_importFrom.png)
]  

‚ö†Ô∏è Ces lignes restent √† adapter :   
- il faut pr√©fixer les datasets, mais ne pas les faire figurer dans une balise importFrom qui est r√©serv√©e aux fonctions,
- on n'importe pas les autres fonctions du package en cours de d√©veloppement, 
- le pronom `.data` n'est pas pr√©fix√© : ajouter `importFrom rlang .data` quand on y recourt.
---
#### Documenter votre fonction - Astuces `{prefixer}`  
# Commande addin `Not-ASCII`  

Utiliser un encodage multi-plateforme est absolument n√©cessaire pour que notre package puisse fonctionner partout, que ce soit sur un serveur linux, un PC, un Mac... 

.pull-left[

La commande `@Not-ASCII` :

- scanne l'ensemble du fichier contenant le script de d√©finition de fonction,    
- y d√©tecte tous les caract√®res √† probl√®me (entre "quote"),    
- et les convertit avec leur code unicode.   
]
.pull-right[
Par exemple :  

```r
filter(dataset, TypeZone == "R√©gions")
```
  
devient : 

```r
filter(dataset, TypeZone == "R\u00e9gions")
```
]   


Cela ne fonctionne pas dans les commentaires de documentation, de toutes fa√ßons, ils ne seraient rendus correctement.
---
#### Documenter votre fonction

# {roxygen2} : document()

.pull-left[
Une fois votre documentation effectu√©e, la fonction `devtools::document()` va exploiter ces balises en   

1. cr√©ant le fichier de documentation de votre fonction, `ma_fonction.Rd`, dans le r√©pertoire `man/` et   
2. en mettant √† jour le fichier NAMESPACE. 

`devtools::check()` int√®gre `devtools::document()` donc vous aurez au d√©part rarement √† utiliser `devtools::document()` de fa√ßon isol√©e.
]
.pull-right[

```r
&gt; devtools::document()
Updating monpackage documentation
Loading monpackage
Writing NAMESPACE
Writing NAMESPACE
Writing ma_fonction.Rd
```

]


---
#### Documenter votre fonction

# {roxygen2} : document()

.pull-left[
Une fois votre documentation effectu√©e, la fonction `devtools::document()` va exploiter ces balises en   

1. cr√©ant le fichier de documentation de votre fonction, **`ma_fonction.Rd`**, dans le r√©pertoire `man/` et   
2. en mettant √† jour le fichier NAMESPACE. 

`devtools::check()` int√®gre `devtools::document()` donc vous aurez au d√©part rarement √† utiliser `devtools::document()` de fa√ßon isol√©e.
]
.pull-right[
![](www/ma_fonction_rd.png)
]
---
#### Documenter votre fonction

# {roxygen2} : document()

.pull-left[
Une fois votre documentation effectu√©e, la fonction `devtools::document()` va exploiter ces balises en   

1. cr√©ant le fichier de documentation de votre fonction, `ma_fonction.Rd`, dans le r√©pertoire `man/` et   
2. en mettant √† jour le fichier **NAMESPACE**.  

`devtools::check()` int√®gre `devtools::document()` donc vous aurez au d√©part rarement √† utiliser `devtools::document()` de fa√ßon isol√©e.
]
.pull-right[
![](www/namespace.png)
]

---
#### Documenter votre fonction

# Partie 'imports' de DESCRIPTION
Il reste une derni√®re chose √† faire pour que les d√©pendances de notre package soient trait√©es correctement : d√©clarer le ou les packages dont d√©pend notre fonction au niveau du fichier DESCRIPTION.

Cela se fait notamment avec l'instruction `usethis::use_package("nomdupackage")` √† consigner dans le dev_history.R.  
Dans le cas de notre exemple : `usethis::use_package("dplyr")`
.pull-left[
![](www/use_package_devhist.png)
]
.pull-right[


```r
&gt; usethis::use_package("dplyr")
‚àö Setting active project to 'C:/Users/juliette.engelaere/Documents/Travail/R_local/monpremierpackage'
* Refer to functions with `dplyr::fun()`
```
]
---

#### Documenter votre fonction

# Partie 'imports' de DESCRIPTION
L'instruction `usethis::use_package` va compl√©ter notre fichier DESCRIPTION au niveau de la partie 'imports' :

![](www/use_package_description.png)  
Le fichier DESCRIPTION peut √™tre compl√©t√© √† la main.  
---
#### Documenter votre fonction

# Partie 'imports' de DESCRIPTION
Dans le cas de d√©pendance √† des packages **qui ne sont pas h√©berg√©s par le CRAN** (par exemple COGiter), il faut le pr√©ciser. 
Sans √ßa, la gestion de cette d√©pendance ne sera pas trait√©e correctement par R lors de l'installation du package par l'utilisateur.  
.pull-left[
Cela se fait par exemple avec :   

```r
&gt; usethis::use_dev_package("COGiter", type = "Imports", remote = "gitlab::dreal-datalab/cogiter")
‚àö Adding 'gitlab::dreal-datalab/cogiter' to Remotes field in DESCRIPTION
* Refer to functions with `COGiter::fun()`
```
]
.pull-right[
Cela a pour effet d'ajouter une partie *'Remotes :'* √† notre fichier description :
![](www/use_remote_package.png)
]
---
class: inverse, center, middle
# Tester votre fonction
---
#### Tester votre fonction
# Qu'est ce qu'un test ?

Une fois une fonction ajout√©e √† votre package, vous allez cr√©er un ou plusieurs tests la concernant.

Un test d√©finit un comportement attendu de votre fonction.

Par exemple, on s'attend √† ce que 2+2 soit √©gal √† 4. Plus g√©n√©ralement on s'attend √† ce qu'une addition renvoie un nombre.

Sur notre exemple de fonction, le r√©sultat de `ma_fonction()` doit √™tre un *dataframe*.

On va pouvoir √©crire un test qui cherche √† v√©rifier cela sur un exemple particulier.
---
#### Tester votre fonction  
# Pourquoi faire un test ?  

Les tests permettent de s√©curiser votre d√©veloppement. 

Imaginez sur notre exemple que la d√©finition de `slice_head()` et que par exemple le param√®tre `n` change de nom et devient `nb`. 

Le fait d'avoir d√©fini un test pour s'assurer sur un jeu d'exemples du r√©sultats attendu vous permettra tr√®s vite d'identifier ce changement.
---
#### Tester votre fonction  
# Comment faire un test ?  

- R√©fl√©chir au comportement attendu de la fonction.
Dans notre exemple, le r√©sultat de notre fonction est un dataframe de `n_head` + `n_tail` lignes.

.pull-left[
- Gr√¢ce √† `{usethis}` :  

  * initialiser les tests dans `dev_history.R`,    
  * et cr√©er le fichier du test de la fonction `ma_fonction()`.
]
.pull-right[
On recourt pour cela √† la librairie `{testthat}`.  

```r
usethis::use_testthat()
usethis::use_test("ma_fonction")
```
]

Un r√©pertoire `tests` d√©di√© aux tests a √©t√© cr√©√© √† la racine du projet.
Il contient un premier script R, `testthat.R`, qui initie les tests de notre package, et un r√©pertoire `testthat` qui contient les fichiers de tests de chaque fonction.
---
#### Tester votre fonction  
# Comment faire un test ?  

.pull-left[
- Dans le fichier de test `test-ma_fonction.R` qui s'est ouvert, 
on ex√©cute la fonction et on v√©rifie que le r√©sultat a les propri√©t√©s attendues.
]

.pull-right[

```r
objet &lt;- ma_fonction(data = iris, n_head = 3, n_tail = 3)

test_that("ma_fonction() renvoie un dataframe", {
  expect_is(objet, "data.frame")
})

test_that("ma_fonction() renvoie le bon nombre de lignes", {
  expect_equal(nrow(objet), 6)
})
```
]

Lors d'une prochaine v√©rification de notre package, avec `devtools::check()`, le test sera automatiquement ex√©cut√©.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>`"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
